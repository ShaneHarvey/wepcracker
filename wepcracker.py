
__author__ = 'shane'


def ksa(k):
    """
    KSA(K)
        Initialization:
        For i = 0 ... N - 1
            S[i] = i
        j = 0
        Scrambling:
        For i = 0 ... N - 1
            j = j + S[i] + K[i mod l]
            Swap(S[i], S[j])

    :param k: the byte array key (IV prepended to the secret key)
    :return: a pseudo random permutation of [0, 1, 2,..., 255]
    """
    s = [i for i in range(256)]
    j = 0
    for i in range(length):
        j = (j + s[i] + k[i % len(k)]) % 256
        # Swap(s[i], s[j])
        temp = s[i]
        s[i] = s[j]
        s[j] = temp
    return s



def prga(s, datalength):
    """
    PRGA(K)
        Initialization:
        i = 0
        j = 0
        Generation Loop:
            i = i + 1
            j = j + S[i]
            Swap(S[i], S[j])
            Output z = S[S[i] + S[j]]

    :param s: a pseudo random permutation of [0, 1, 2,..., 255] generated by ksa
    :param datalength: length of the packet data (message + checksum) in bytes
    :return: a byte array to XOR the packet data with
    """
    z = []
    i = 0
    j = 0
    for x in range(datalength):
        i = (i+1) % 256
        j = (j + s[i+1]) % 256
        # Swap(s[i], s[j])
        temp = s[i]
        s[i] = s[j]
        s[j] = temp
        z.append(s[(s[i] + s[j]) % 256])
    return z
"""
Starting IV = (3, 255, x)
Then for byte a of the key we need IV = (a+3, n-1, x)

"""

def crackWEPkey(keysize, packets):
    """
    Starting IV = (3, 255, x)
    Then for byte a of the key we need IV = (a+3, 255, x)

    """
    key = [0] * keysize
    for keybyte in range(keysize):
        counts = [0] * 256
        for p in packets[keybyte+3]:
            # construct key counts
        # key[keybyte] = index of max(counts)
        key[keybyte] = max(enumerate(counts), key=lambda x: x[1])[0]
    return key


def main():
    print("WEPcracker")

if __name__ == '__main__':
    main()